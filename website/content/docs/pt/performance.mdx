---
title: Performance
description: Otimize sua aplica√ß√£o AzuraJS para m√°ximo desempenho
icon: Lightbulb
---

# Performance üí°

Aprenda t√©cnicas e melhores pr√°ticas para maximizar o desempenho da sua aplica√ß√£o AzuraJS.

## Cluster Mode üñ•Ô∏è

A maneira mais eficaz de melhorar o desempenho √© ativar cluster mode - simplesmente defina na configura√ß√£o e AzuraJS cuida de tudo automaticamente:

```typescript title="azura.config.ts"
import type { ConfigTypes } from "azurajs/config";

const config: ConfigTypes = {
  server: {
    cluster: true,  // AzuraJS utiliza automaticamente todos os n√∫cleos da CPU
  },
};

export default config;
```

**Ganhos esperados:**
- 4 cores: ~3.5x throughput
- 8 cores: ~7x throughput
- 16 cores: ~14x throughput

**Nenhum c√≥digo manual necess√°rio** - AzuraJS automaticamente cria workers, distribui carga e gerencia crashes.

Veja o [guia completo de Cluster Mode](/docs/pt/cluster-mode) para todos os detalhes.

## Caching Estrat√©gico üíæ

### Cache em Mem√≥ria

```typescript
const cache = new Map<string, { data: any; expires: number }>();

function cacheMiddleware(ttl: number) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    if (req.method !== "GET") {
      return next();
    }
    
    const key = req.url;
    const cached = cache.get(key);
    
    // Verificar cache
    if (cached && Date.now() < cached.expires) {
      return res.json(cached.data);
    }
    
    // Interceptar resposta
    const originalJson = res.json.bind(res);
    res.json = function(data: any) {
      cache.set(key, { data, expires: Date.now() + ttl });
      return originalJson(data);
    };
    
    next();
  };
}

// Cache de 5 minutos para dados p√∫blicos
app.use("/api/public", cacheMiddleware(300000));
```

### Cache com Redis

```typescript
import { createClient } from "redis";

const redis = createClient();
await redis.connect();

async function redisCacheMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  if (req.method !== "GET") {
    return next();
  }
  
  const key = `cache:${req.url}`;
  
  try {
    const cached = await redis.get(key);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }
    
    const originalJson = res.json.bind(res);
    res.json = async function(data: any) {
      await redis.setEx(key, 300, JSON.stringify(data));
      return originalJson(data);
    };
    
    next();
  } catch (error) {
    next();  // Falhar aberto
  }
}

app.use(redisCacheMiddleware);
```

## Otimiza√ß√£o de Banco de Dados üóÑÔ∏è

### Connection Pooling

```typescript
import { Pool } from "pg";

const pool = new Pool({
  host: "localhost",
  port: 5432,
  database: "mydb",
  user: "user",
  password: "password",
  max: 20,  // M√°ximo de 20 conex√µes
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
});

@Get("/users")
async getUsers() {
  const client = await pool.connect();
  try {
    const result = await client.query("SELECT * FROM users");
    return { users: result.rows };
  } finally {
    client.release();
  }
}
```

### Query Optimization

```typescript
// ‚ùå N+1 Query Problem
async function getBadPosts() {
  const posts = await db.query("SELECT * FROM posts");
  
  for (const post of posts) {
    post.author = await db.query("SELECT * FROM users WHERE id = $1", [post.authorId]);
  }
  
  return posts;
}

// ‚úÖ Single Query with JOIN
async function getGoodPosts() {
  const posts = await db.query(`
    SELECT posts.*, users.name as author_name, users.email as author_email
    FROM posts
    LEFT JOIN users ON posts.author_id = users.id
  `);
  
  return posts;
}
```

### √çndices

```sql
-- Criar √≠ndices para queries frequentes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_posts_author_id ON posts(author_id);
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);

-- √çndice composto para queries espec√≠ficas
CREATE INDEX idx_posts_status_created ON posts(status, created_at DESC);
```

## Pagina√ß√£o Eficiente üìÑ

```typescript
interface PaginationQuery {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
}

@Get("/posts")
async getPosts(@Query() query: PaginationQuery) {
  const page = Math.max(1, query.page || 1);
  const limit = Math.min(100, Math.max(1, query.limit || 10));
  const offset = (page - 1) * limit;
  const sortBy = query.sortBy || "created_at";
  const sortOrder = query.sortOrder || "desc";
  
  // Query com LIMIT e OFFSET
  const posts = await db.query(`
    SELECT * FROM posts
    ORDER BY ${sortBy} ${sortOrder}
    LIMIT $1 OFFSET $2
  `, [limit, offset]);
  
  // Count total (pode ser cacheado)
  const total = await db.query("SELECT COUNT(*) FROM posts");
  
  return {
    posts,
    pagination: {
      page,
      limit,
      total: total.rows[0].count,
      totalPages: Math.ceil(total.rows[0].count / limit)
    }
  };
}
```

## Compression üóúÔ∏è

```typescript
import { gzipSync } from "zlib";

function compressionMiddleware(req: RequestServer, res: ResponseServer, next: () => void) {
  const acceptEncoding = req.headers["accept-encoding"] || "";
  
  if (!acceptEncoding.includes("gzip")) {
    return next();
  }
  
  const originalJson = res.json.bind(res);
  const originalSend = res.send.bind(res);
  
  res.json = function(data: any) {
    const json = JSON.stringify(data);
    const compressed = gzipSync(json);
    
    res.setHeader("Content-Encoding", "gzip");
    res.setHeader("Content-Type", "application/json");
    return originalSend(compressed);
  };
  
  next();
}

app.use(compressionMiddleware);
```

## Lazy Loading üîÑ

```typescript
// Carregar apenas o necess√°rio
@Get("/posts/:id")
async getPost(@Param("id") id: string, @Query("include") include: string) {
  const post = await db.query("SELECT * FROM posts WHERE id = $1", [id]);
  
  // Carregar relacionamentos apenas se solicitado
  if (include?.includes("author")) {
    post.author = await db.query("SELECT * FROM users WHERE id = $1", [post.authorId]);
  }
  
  if (include?.includes("comments")) {
    post.comments = await db.query("SELECT * FROM comments WHERE post_id = $1", [post.id]);
  }
  
  return { post };
}
```

## Rate Limiting Inteligente üõ°Ô∏è

```typescript
// Rate limit mais alto para usu√°rios autenticados
function smartRateLimit(req: RequestServer, res: ResponseServer, next: () => void) {
  const isAuthenticated = !!req.user;
  
  const limit = isAuthenticated ? 1000 : 100;  // 10x mais para usu√°rios autenticados
  const windowMs = 60000;  // 1 minuto
  
  const key = isAuthenticated ? `auth:${req.user.id}` : `anon:${req.ip}`;
  
  // Implementar rate limiting com limite din√¢mico
  const allowed = checkRateLimit(key, windowMs, limit);
  
  if (!allowed) {
    return res.status(429).json({ error: "Rate limit excedido" });
  }
  
  next();
}
```

## Async/Await vs Promises.all üîÄ

```typescript
// ‚ùå Lento - Execu√ß√£o sequencial
async function slowFetch() {
  const users = await fetchUsers();      // Espera 100ms
  const posts = await fetchPosts();      // Espera 100ms
  const comments = await fetchComments();  // Espera 100ms
  // Total: 300ms
  
  return { users, posts, comments };
}

// ‚úÖ R√°pido - Execu√ß√£o paralela
async function fastFetch() {
  const [users, posts, comments] = await Promise.all([
    fetchUsers(),      // Executa em paralelo
    fetchPosts(),      // Executa em paralelo
    fetchComments()    // Executa em paralelo
  ]);
  // Total: 100ms (tempo da opera√ß√£o mais lenta)
  
  return { users, posts, comments };
}
```

## Streaming üåä

Para respostas grandes, use streaming:

```typescript
import { createReadStream } from "fs";

@Get("/download/large-file")
downloadFile(@Res() res: ResponseServer) {
  const stream = createReadStream("./large-file.csv");
  
  res.setHeader("Content-Type", "text/csv");
  res.setHeader("Content-Disposition", "attachment; filename=data.csv");
  
  stream.pipe(res);
}
```

## Evitar Bloqueio da Event Loop üîÑ

```typescript
// ‚ùå Ruim - Bloqueia event loop
@Get("/heavy")
heavyComputation() {
  let result = 0;
  for (let i = 0; i < 10000000000; i++) {
    result += i;
  }
  return { result };
}

// ‚úÖ Bom - Usa worker threads
import { Worker } from "worker_threads";

@Get("/heavy")
async heavyComputation() {
  return new Promise((resolve, reject) => {
    const worker = new Worker("./heavy-worker.js");
    
    worker.on("message", resolve);
    worker.on("error", reject);
    worker.on("exit", (code) => {
      if (code !== 0) {
        reject(new Error(`Worker stopped with exit code ${code}`));
      }
    });
  });
}

// heavy-worker.js
const { parentPort } = require("worker_threads");

let result = 0;
for (let i = 0; i < 10000000000; i++) {
  result += i;
}

parentPort.postMessage({ result });
```

## Benchmarking üìä

Use ferramentas para medir desempenho:

```bash
# Autocannon (Node.js)
npm install -g autocannon
autocannon -c 100 -d 10 http://localhost:3000/api/users

# Apache Bench
ab -n 10000 -c 100 http://localhost:3000/api/users

# wrk
wrk -t12 -c400 -d30s http://localhost:3000/api/users
```

### Exemplo de Benchmark

```typescript
import autocannon from "autocannon";

async function benchmark() {
  const result = await autocannon({
    url: "http://localhost:3000",
    connections: 100,
    duration: 10,
    pipelining: 1,
    requests: [
      {
        method: "GET",
        path: "/api/users"
      }
    ]
  });
  
  console.log(`Requests/sec: ${result.requests.mean}`);
  console.log(`Latency (avg): ${result.latency.mean}ms`);
  console.log(`Throughput: ${result.throughput.mean} bytes/sec`);
}

benchmark();
```

## Monitoramento üìà

```typescript
import { performance } from "perf_hooks";

function performanceMiddleware(req: RequestServer, res: ResponseServer, next: () => void) {
  const start = performance.now();
  
  res.on("finish", () => {
    const duration = performance.now() - start;
    
    console.log({
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration.toFixed(2)}ms`
    });
    
    // Alertar se requisi√ß√£o demorar muito
    if (duration > 1000) {
      console.warn(`‚ö†Ô∏è Slow request: ${req.method} ${req.url} took ${duration.toFixed(2)}ms`);
    }
  });
  
  next();
}

app.use(performanceMiddleware);
```

## Otimiza√ß√µes de Produ√ß√£o üöÄ

### Vari√°veis de Ambiente

```typescript
const app = new AzuraClient({
  environment: "production",
  logging: {
    level: process.env.NODE_ENV === "production" ? "error" : "debug"
  }
});
```

### PM2 Configuration

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: "azura-app",
    script: "./dist/server.js",
    instances: "max",  // Usar todos os cores
    exec_mode: "cluster",
    env_production: {
      NODE_ENV: "production",
      PORT: 3000
    },
    max_memory_restart: "500M",
    error_file: "./logs/error.log",
    out_file: "./logs/out.log",
    log_date_format: "YYYY-MM-DD HH:mm:ss Z"
  }]
};
```

## Checklist de Performance ‚úÖ

<Callout type="tip">
  ‚úÖ **Usar cluster mode** para utilizar todos os cores da CPU
</Callout>

<Callout type="tip">
  ‚úÖ **Implementar caching** para dados que n√£o mudam frequentemente
</Callout>

<Callout type="tip">
  ‚úÖ **Otimizar queries de banco** com √≠ndices e JOINs adequados
</Callout>

<Callout type="tip">
  ‚úÖ **Usar connection pooling** para banco de dados
</Callout>

<Callout type="tip">
  ‚úÖ **Comprimir respostas** com gzip
</Callout>

<Callout type="tip">
  ‚úÖ **Paginar resultados** para limitar dados transferidos
</Callout>

<Callout type="tip">
  ‚úÖ **Usar Promise.all** para opera√ß√µes paralelas
</Callout>

<Callout type="tip">
  ‚úÖ **Monitorar desempenho** com m√©tricas e logs
</Callout>

<Callout type="warn">
  ‚ö†Ô∏è **Evitar bloqueio da event loop** com opera√ß√µes s√≠ncronas pesadas
</Callout>

<Callout type="warn">
  ‚ö†Ô∏è **N√£o fazer queries N+1** - sempre usar JOINs ou batch queries
</Callout>

## Compara√ß√£o de Performance üìä

**Servidor √∫nico vs Cluster (8 cores):**

```
Single Process:
  Requests/sec: 5,000
  Latency: 20ms

Cluster Mode (8 cores):
  Requests/sec: 35,000
  Latency: 3ms
  
Ganho: 7x throughput, 6.6x lat√™ncia
```

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Cluster Mode" href="cluster-mode" description="Configure cluster mode" />
  <Card title="Exemplos" href="examples" description="Veja implementa√ß√µes completas" />
  <Card title="Error Handling" href="error-handling" description="Trate erros eficientemente" />
</Cards>
